{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My personal notes on concepts worth mentioning.","title":"Home"},{"location":"architecture/practice/","text":"Components are only half the architecture When we think of systems architecture we usually picture a diagram with components and their relations, sometimes complemented with principles on how to structure them. Components are only half the architecture though. The other half are the people and their practices that make the components. They are at least as important, but are almost never taken into consideration. This is like the design of a car, without the factory to actually make it. Their practices should be centered around change and maintenance as systems do not run themselves. Systems require continual adaptation and maintenance after their conception to stay relevant. Like the car, it needs a garage and maintenance schedule. Or maybe there is no garage in IT and it is the factory that needs to reproduce a fitting means of transportation each day. Be it a sedan, a station wagon or an SUV. All the more reason to pay attention to the architecture of the factory; to the architecture of our practices.","title":"Practice"},{"location":"architecture/practice/#components-are-only-half-the-architecture","text":"When we think of systems architecture we usually picture a diagram with components and their relations, sometimes complemented with principles on how to structure them. Components are only half the architecture though. The other half are the people and their practices that make the components. They are at least as important, but are almost never taken into consideration. This is like the design of a car, without the factory to actually make it. Their practices should be centered around change and maintenance as systems do not run themselves. Systems require continual adaptation and maintenance after their conception to stay relevant. Like the car, it needs a garage and maintenance schedule. Or maybe there is no garage in IT and it is the factory that needs to reproduce a fitting means of transportation each day. Be it a sedan, a station wagon or an SUV. All the more reason to pay attention to the architecture of the factory; to the architecture of our practices.","title":"Components are only half the architecture"},{"location":"deep-work/rules/","text":"Deep Work Rules Rules for a rythmic deep work schedule. Plan sessions of 60 to 90 minutes in your agenda for doing deep work. Plan this weekly and refine daily at set times. Plan both subject and goal for each session in advance. Follow the optimal process given de subject during each session. At the start of the session close all communication and distractions. Open only your reference material and your output. Put on your headphone and start supporting music. Set your phone to quiet and put it face down on the table. Close Teams, Chats and Emails. Close Planners and Agendas. Close Windows that don't contribute to the subject. Close Notes. Open a new notepad if needed. At the end of the session open all communication channels and answer all simple and urgent requests. Stop the music. Check your phone for calls and messages. Open Teams, Chats and Emails. Evaluate the sessions ouput and process.","title":"Rules"},{"location":"deep-work/rules/#deep-work-rules","text":"Rules for a rythmic deep work schedule. Plan sessions of 60 to 90 minutes in your agenda for doing deep work. Plan this weekly and refine daily at set times. Plan both subject and goal for each session in advance. Follow the optimal process given de subject during each session. At the start of the session close all communication and distractions. Open only your reference material and your output. Put on your headphone and start supporting music. Set your phone to quiet and put it face down on the table. Close Teams, Chats and Emails. Close Planners and Agendas. Close Windows that don't contribute to the subject. Close Notes. Open a new notepad if needed. At the end of the session open all communication channels and answer all simple and urgent requests. Stop the music. Check your phone for calls and messages. Open Teams, Chats and Emails. Evaluate the sessions ouput and process.","title":"Deep Work Rules"},{"location":"deep-work/types/","text":"Deep Work Types Concept (architecture) Result: The definition and structuring of concepts that form the context of design. The main input of this type of work should be function. Design Result: Diagrams with supporting descriptions and assumptions that form the basis of future builds or clarify recent new builds. A design satisfies a complex set of goals (requirements). Design requires detailed knowledge of the build options, which comes from both documentation and build experience. It might also require the knowledge of previous designs like frameworks and standards if they are available. So design work should be preceded by the search for such designs. Build Result: Automated deployment of a service or component that satisfies a clear goal. Build work requires a clear goal and optionally a design when available. Note that Build and Design form an interplay. Build work is the transformation of documentation and experience into an automated deployment. Process Result: Work instructions that are simple enough to become habits.","title":"Types"},{"location":"deep-work/types/#deep-work-types","text":"","title":"Deep Work Types"},{"location":"deep-work/types/#concept-architecture","text":"Result: The definition and structuring of concepts that form the context of design. The main input of this type of work should be function.","title":"Concept (architecture)"},{"location":"deep-work/types/#design","text":"Result: Diagrams with supporting descriptions and assumptions that form the basis of future builds or clarify recent new builds. A design satisfies a complex set of goals (requirements). Design requires detailed knowledge of the build options, which comes from both documentation and build experience. It might also require the knowledge of previous designs like frameworks and standards if they are available. So design work should be preceded by the search for such designs.","title":"Design"},{"location":"deep-work/types/#build","text":"Result: Automated deployment of a service or component that satisfies a clear goal. Build work requires a clear goal and optionally a design when available. Note that Build and Design form an interplay. Build work is the transformation of documentation and experience into an automated deployment.","title":"Build"},{"location":"deep-work/types/#process","text":"Result: Work instructions that are simple enough to become habits.","title":"Process"},{"location":"tech/trust_tls/","text":"Trusting TLS TLS is one of the most used and, at the same time, one of the least understood technologies. Yes, it secures your connections, but how it does that seems to be a mystery. This leaves us susceptible to vague statements like \"your credit cards will be stolen when you use self-signed certificates\" and \"turning off host verification will make your server vulnerable to hackers\". Nobody knows, but it sounds scary, so it must be true. So what is the deal with TLS and is it really that scary? TLS has two functions*. The first is the encryption of data in transit, and the second is providing trusted connections. Encryption is the main one. That is the reason we have TLS. Trust is an extra that has its use, but does not compare in importance to encryption. It is however the one that we get worked up about. Let's look at each function in isolation. *Actually, TLS has more functions, but they pale in application compared to these two. Encryption TLS encrypts the TCP data packets between client and server. It does so by exchanging a symmetric key that both the client and the server use to encrypt and decrypt the packets. This ensures that only the client and server can read the data that they exchange, but that no other intermediate system on the network can eavesdrop. Of course there are complex details, but this is the essence and there really isn't more to it. Data is encrypted in transit. That is it. Trust TLS can also provide a level of trust about the server that the client connects to using PKI certificates. The server provides the client a certificate that holds the address of the server and is signed by a third party, the Certificate Authority. This way, the client can verify independently that it is connecting to the intended server. This trust function is relevant on an untrusted public network, where client traffic can be intercepted by another server that poses as the intended server. The client can then be tricked into divulging sensitive information, like a password or credit card information. The trust function verifies that the connecting server corresponds with the intended address. This is a useful function on an uncontrolled public network to provide assurance that the data reaches the intended recipient. On a controlled private network though, this is useless at best, but is probably an active hindrance. Here is why. Trust on a client, or more accurately \"TLS host verification\", works by first trusting the certificate of the Certificate Authority (CA) that signed the server certificate. By trusting the CA the client implicitly trusts all the server certificates it signs. This works well on the internet where our browsers and operating systems trust a list of commercial CA's by default and where we buy all the public server certificates from these CA's. So because Google trusts a bunch of CA's and packages Chrome with their signing certificates, and the company whose website you're surfing has bought its server certificate from those CA's, you don't have to worry about your TLS configuration. How different that is on a private network. Instead of using prepackaged commercial CA's, you can also create your own singing certificate. Technically, this provides the same level of trust and is cheaper, because you can make as many server certificates as you want for free. The downside of this solution is that you have to configure each client to trust your signing certificate for all the TLS-based connections to work. That is when you should evaluate the trust function itself. Is there a chance that a client can connect to an unverified server and that it can thereby disclose sensitive information? If the answer is yes, then make the administrative investment of configuring each client to trust your signing certificate. If the answer is no on the other hand, then you might be better off with setting the 'host verification' parameter to 'false' in your TLS connections. It disables trust, relieves you off needless configuration and leaves only with its primary function; encryption of data in transit. No more, no less.","title":"Trusting TLS"},{"location":"tech/trust_tls/#trusting-tls","text":"TLS is one of the most used and, at the same time, one of the least understood technologies. Yes, it secures your connections, but how it does that seems to be a mystery. This leaves us susceptible to vague statements like \"your credit cards will be stolen when you use self-signed certificates\" and \"turning off host verification will make your server vulnerable to hackers\". Nobody knows, but it sounds scary, so it must be true. So what is the deal with TLS and is it really that scary? TLS has two functions*. The first is the encryption of data in transit, and the second is providing trusted connections. Encryption is the main one. That is the reason we have TLS. Trust is an extra that has its use, but does not compare in importance to encryption. It is however the one that we get worked up about. Let's look at each function in isolation. *Actually, TLS has more functions, but they pale in application compared to these two. Encryption TLS encrypts the TCP data packets between client and server. It does so by exchanging a symmetric key that both the client and the server use to encrypt and decrypt the packets. This ensures that only the client and server can read the data that they exchange, but that no other intermediate system on the network can eavesdrop. Of course there are complex details, but this is the essence and there really isn't more to it. Data is encrypted in transit. That is it. Trust TLS can also provide a level of trust about the server that the client connects to using PKI certificates. The server provides the client a certificate that holds the address of the server and is signed by a third party, the Certificate Authority. This way, the client can verify independently that it is connecting to the intended server. This trust function is relevant on an untrusted public network, where client traffic can be intercepted by another server that poses as the intended server. The client can then be tricked into divulging sensitive information, like a password or credit card information. The trust function verifies that the connecting server corresponds with the intended address. This is a useful function on an uncontrolled public network to provide assurance that the data reaches the intended recipient. On a controlled private network though, this is useless at best, but is probably an active hindrance. Here is why. Trust on a client, or more accurately \"TLS host verification\", works by first trusting the certificate of the Certificate Authority (CA) that signed the server certificate. By trusting the CA the client implicitly trusts all the server certificates it signs. This works well on the internet where our browsers and operating systems trust a list of commercial CA's by default and where we buy all the public server certificates from these CA's. So because Google trusts a bunch of CA's and packages Chrome with their signing certificates, and the company whose website you're surfing has bought its server certificate from those CA's, you don't have to worry about your TLS configuration. How different that is on a private network. Instead of using prepackaged commercial CA's, you can also create your own singing certificate. Technically, this provides the same level of trust and is cheaper, because you can make as many server certificates as you want for free. The downside of this solution is that you have to configure each client to trust your signing certificate for all the TLS-based connections to work. That is when you should evaluate the trust function itself. Is there a chance that a client can connect to an unverified server and that it can thereby disclose sensitive information? If the answer is yes, then make the administrative investment of configuring each client to trust your signing certificate. If the answer is no on the other hand, then you might be better off with setting the 'host verification' parameter to 'false' in your TLS connections. It disables trust, relieves you off needless configuration and leaves only with its primary function; encryption of data in transit. No more, no less.","title":"Trusting TLS"}]}